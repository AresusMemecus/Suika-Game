<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fruit Physics Game</title>
    <style>
        canvas {
            display: block;
            margin: 0 auto;
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Устанавливаем размеры канваса
        canvas.width = 300;
        canvas.height = 500;

        const fruits = [
            { name: 'watermelon', color: 'red', size: 20 },
            { name: 'grape', color: 'orange', size: 30 },
            { name: 'grape', color: 'yellow', size: 40 },
            { name: 'grape', color: 'green', size: 60 },
            { name: 'grape', color: 'blue', size: 80 },
            { name: 'grape', color: '#ADD8E6', size: 120 },
            { name: 'grape', color: 'black', size: 140 },
            { name: 'grape', color: 'gary', size: 170 },
            { name: 'grape', color: 'brown', size: 200 },
            { name: 'grape', color: 'magenta', size: 240 },
            { name: 'grape', color: 'purple', size: 300 }
        ];

        // Настройка Matter.js
        const { Engine, Render, Runner, Bodies, Composite, Mouse, MouseConstraint, Events } = Matter;

        const engine = Engine.create();
        const world = engine.world;

        // Создаем рендерер
        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: canvas.width,
                height: canvas.height,
                wireframes: false,
                background: '#f0f0f0'
            }
        });

        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        // Создание границ стакана
        const ground = Bodies.rectangle(canvas.width / 2, canvas.height + 10, canvas.width, 20, { isStatic: true });
        const leftWall = Bodies.rectangle(-10, canvas.height / 2, 20, canvas.height, { isStatic: true });
        const rightWall = Bodies.rectangle(canvas.width + 10, canvas.height / 2, 20, canvas.height, { isStatic: true });

        Composite.add(world, [ground, leftWall, rightWall]);

        // Функция для создания случайного фрукта
        function createFruit(x, y, sizeIndex) {
            const fruitData = fruits[sizeIndex];
            const fruit = Bodies.circle(x, y, fruitData.size / 2, {
                restitution: 0.5, // Упругость
                friction: 0.01,   // Трение
                label: sizeIndex.toString(), // Сохраняем индекс размера как метку
                render: {
                    fillStyle: fruitData.color
                }
            });
            Composite.add(world, fruit);
            return fruit;
        }

        // Обработчик клика для создания фрукта
        canvas.addEventListener('click', function(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const randomSizeIndex = Math.floor(Math.random() * 1);
            createFruit(x, y, randomSizeIndex);
        });



       // Обработка событий столкновений
Events.on(engine, 'collisionStart', function(event) {
    const pairs = event.pairs;
    const collisions = {};

    pairs.forEach(pair => {
        const bodyA = pair.bodyA;
        const bodyB = pair.bodyB;

        // Проверяем, совпадают ли размеры двух шаров
        if (bodyA.label === bodyB.label) {
            const sizeIndex = parseInt(bodyA.label);

            // Сохраняем информацию о столкновении
            if (!collisions[sizeIndex]) {
                collisions[sizeIndex] = [];
            }
            collisions[sizeIndex].push({ bodyA, bodyB });
        }
    });

    // Обрабатываем столкновения
    for (const sizeIndex in collisions) {
        const collisionGroup = collisions[sizeIndex];

        // Обрабатываем только два шара
        if (collisionGroup.length > 0) {
            const { bodyA, bodyB } = collisionGroup[0]; // Берем первое столкновение

            setTimeout(() => {
                // Удаляем оба шара
                Composite.remove(world, bodyA);
                Composite.remove(world, bodyB);

                // Создаем новый шар на ступень выше по размеру, если возможно
                if (parseInt(sizeIndex) + 1 < fruits.length) {
                    const newX = (bodyA.position.x + bodyB.position.x) / 2;
                    const newY = (bodyA.position.y + bodyB.position.y) / 2;
                    createFruit(newX, newY, parseInt(sizeIndex) + 1);
                }
            }, 10); // Задержка перед удалением и созданием нового шара
        }
    }
});


        // Запуск рендера и физики
        Render.run(render);
        Runner.run(runner, engine);

    </script>
</body>
</html>
